
## 0 comparisons

A functional programming language, such as Erlang or Haskell, much of
what you've previously learned about programming languages will just get
in the way. They aren't similar to traditional procedural languages in
any way that's helpful.

## 0 Languages To Address

MUST:
BASIC
C
C++
COBOL

MAYBE:
Perl
    was designed for writing reports

## datalog

NOTE: MAKE A REF TO DATALOG (CONNECTED WITH PROLOG) IN THE PAGE SOMEWHERE

## js - web dev

freeCodeCamp dev quiz - Web Dev - JS

- Specific JS web things
    - JSON stands for JavaScript Object Notation which is a text-based format to store and exchange data.
    - The DOM is a programming interface to create, change, or remove elements from the document.
- It's important to distinguish between client-side and server-side JS
    - client-side is inside

## ocaml

The preferred language of investors is OCamL

- First, Ocaml's design requires programmers to be very explicit about what data they're using and what they're trying to do with it. Excel is happy to tell you that the square root of today's date is 2:22pm on July 29th, 1900; Ocaml will insist that you figure out what you _meant_ to take the square root of first. This has the obvious advantage that it spots certain kinds of bugs before code goes live; it simply won't work if you make certain categories of mistakes, even if what you're doing just consists of known mathematical operations on numbers. It won't catch every bug, of course, but this is helpful.
- More subtly, this system makes it easier to reason about complex systems, since it's easier to see what code is executing when, and what it's trying to accomplish. Complex systems generate edge cases, and in trading edge cases generate bankruptcies. The more a trading system resembles a theorem instead of a recipe, the easier it will be. And code that explicitly declares types also has a form of documentation that's automatically audited by the compiler-you can predict often that the code will do what it says because if it doesn't do that, it won't do anything.

## ruby

From a comment

- Ruby is beautiful. The seamless blend of OO, functional, and imperative programming is beautiful. It can be dense without being obscure. irb and pry make it easy to explore code and data. The syntax is mostly conventional and easy to learn. The standard libraries are well designed, and have consistent interfaces. The documentation is concise and easy to scan. I won't say its "The Best", but of the dynamic, interpreted languages I know, Ruby is the most fun to use, and it starts with the clean, well-considered design right at its core.
