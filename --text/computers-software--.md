
In computer programming, you can make something faster at the cost of needing more (random access) memory or decrease its memory needs at the cost of being slower. A lot of computer evolution, both in hardware and software, has been finding ways to improve the exchange rate or just straight increase the number of resources available to fiddle with.

freeCodeCamp dev quiz - Software Design

- The five phases of the Design Thinking Process are Empathize, Define, Ideate, Prototype, and Test.
- what is grep?
- The Design Thinking Process is a way to come up with creative, user centric solutions to complex problems.
- [The Design Thinking Process Explained](https://www.freecodecamp.org/news/the-design-thinking-process-explained)
- When Pair Programming, one developer is the "driver" with their hands on the keyboard. The other is the "navigator" helping talk through the problem and decide what to do. They periodically switch roles. This is an efficient and commonly used Agile Software Development methodology.

Software needs the ability to code events and objects in such a way
that rough-and-ready versions of statistical principles can be applied
to them.

A building or object should let you use it as you want: a good building,
for example, will serve as a backdrop for whatever life people want to
lead in it, instead of making them live as if they were executing a
program written by the architect.

Hackers need to understand the theory of computation about as much as
painters need to understand paint chemistry.

You should figure out programs as you're writing them, just as writers
and painters and architects do. Realizing this has real implications for
software design. It means that a programming language should, above all,
be malleable. A programming language is for thinking of programs, not
for expressing programs you've already thought of. It should be a
pencil, not a pen.

There are quite a few occasions where an already-present tool should be rebuilt:  
- It's often hard to find _precisely_ what you want, and refactoring can be complicated.
- Some software developers reinvent the wheel or [reverse-engineer something](https://trendless.tech/hacking), just for fun.
- Reinventing the wheel is very educational, even if its results aren't always useful.
- An existing tool might become obsolete, jammed behind a paywall, merged into some bloated software suite, or the software's owner [became tyrannical](https://gainedin.site/bad-systems/) over [their IP](https://notageni.us/ip).
- For any reason whatsoever, a developer may start distrusting software and will make a lobotomized or [open-source](https://trendless.tech/floss/) version of it.
The largest mental wall for most people, though, is knowing a tool even _exists_. If we know another human already did something, we now know it's completely possible, and it's much easier to find motivation to accomplish what we're certain can happen.

## new sites - dev influencers

[Alex Alejandre](https://alexalejandre.com/)

[larry wall](http://www.wall.org/~larry/)
[larry wall](https://web.archive.org/web/20210102182957/http://www.wall.org/~larry/)
the creator of the perl programming language's personal site

[stallman](https://stallman.org/)
richard stallman. nuff said.

[Ask HN: Share your favorite software blog posts of 2023 | Hacker News](https://news.ycombinator.com/item?id=38765176)

[GitHub - sanmak/awesome-blogs: List of awesome blogs run, managed by a human or two and not an organisation, company or institution.](https://github.com/sanmak/awesome-blogs)

[GitHub - m8/refined.blog: curated list of personal blogs](https://github.com/m8/refined.blog)
[Refined Blog](https://m8.github.io/refined.blog/)

[lolwut](https://lolwut.neocities.org/)
[lolwut](https://web.archive.org/web/20210102182957/https://lolwut.neocities.org/)
personal site of a /g/ anon. cool stuff in here

[rmccurdy.com/](https://rmccurdy.com/)

[Randall Bytwerk](https://www.bytwerk.com/)

[za3k.com](https://za3k.com/)

[Hunter Harris's Resume](https://hbh7.com/resume/)

[jwills.co.uk - Coding, retro-gaming, and other projects](https://jwills.co.uk/)

[Greg Tatum](https://gregtatum.com/)

[GitHub - STRML/strml.net: STRML: Projects & Work](https://github.com/STRML/strml.net)
[STRML: Projects and Work](https://www.strml.net/)

[GitHub - jkup/awesome-personal-blogs: A delightful list of personal tech blogs](https://github.com/jkup/awesome-personal-blogs)

[Dev Mastery Newsletter Opt-In](https://www.devmastery.com/)

[Pointer | A Reading Club For Software Developers](https://www.pointer.io/)

[Paper Trail](https://www.the-paper-trail.org)

[Shamus Young Dot Com](https://www.shamusyoung.com/)

### twitter accounts

##### ▪️ Best Personal Twitter Accounts

[@blackroomsec](https://twitter.com/blackroomsec)
a white-hat hacker/pentester. Intergalactic Minesweeper Champion 1990.

[@MarcoCiappelli](https://twitter.com/MarcoCiappelli)
Co-Founder @ITSPmagazine, at the intersection of IT security and society.

[@binitamshah](https://twitter.com/binitamshah)
Linux Evangelist. Malwares. Kernel Dev. Security Enthusiast.

[@joe_carson](https://twitter.com/joe_carson)
an InfoSec Professional and Tech Geek.

[@mikko](https://twitter.com/mikko)
CRO at F-Secure, Reverse Engineer, TED Speaker, Supervillain.

[@esrtweet](https://twitter.com/esrtweet)
often referred to as ESR, is an American software developer, and open-source software advocate.

[@gynvael](https://twitter.com/gynvael)
security researcher/programmer, @DragonSectorCTF founder/player, technical streamer.

[@x0rz](https://twitter.com/x0rz)
Security Researcher & Cyber Observer.

[@TinkerSec](https://twitter.com/TinkerSec)
tinkerer, cypherpunk, hacker.

[@alisaesage](https://twitter.com/alisaesage)
independent hacker and researcher.

[@SwiftOnSecurity](https://twitter.com/SwiftOnSecurity)
systems security, industrial safety, sysadmin, author of decentsecurity.com.

[@dakami](https://twitter.com/dakami)
is one of just seven people with the authority to restore the DNS root keys.

[@samykamkar](https://twitter.com/samykamkar)
is a famous "grey hat" hacker, security researcher, creator of the MySpace "Samy" worm.

[@jack_daniel](https://twitter.com/jack_daniel)
@SecurityBSides co-founder.

[@thegrugq](https://twitter.com/thegrugq)
Security Researcher.

##### ▪️ Best Commercial Twitter Accounts

[@attcyber](https://twitter.com/attcyber)
AT&T Cybersecurity's Edge-to-Edge technologies provide threat intelligence, and more.

[@hedgehogsec](https://twitter.com/hedgehogsec)
Hedgehog Cyber. Gibraltar and Manchester's top boutique information security firm.

## new sites - engineering blogs

[GitHub - flesch/random-engineering-blog: Bored? Read a random engineering blog.](https://github.com/flesch/random-engineering-blog)

[GitHub - kilimchoi/engineering-blogs: A curated list of engineering blogs](https://github.com/kilimchoi/engineering-blogs)

[GitHub - MartinsOnuoha/company-engineering-blogs: A collection of companies' engineering blogs, to help you improve your software engineering skill and learn how their software work. ](https://github.com/MartinsOnuoha/company-engineering-blogs)

## skills

NOTE: indicate stuff like exercism and hacktoberfest for the purposes of sharpening the sword.

## veteran advice

When making software on a website, make it as easy and quick as possible for the new leads to poke around with it
if people get to "test drive" it, they can feel what the product is capable of

Programming languages are what programmers think in.

### Code

Code is a liability, not an asset. Aim to have as little of it as possible.

Build programs out of pure functions. This saves you from spending your brain power on tracking side effects, mutated state and actions at a distance.

Use a programming language with a rich type system that lets you describe the parts of your code and checks your program at compile time.

The expressivity of a programming language matters hugely. It’s not just a convenience to save keypresses, it directly influences the way in which you write code.

Choose a programming language that has a good module system, and use it. Be explicit about the public interface of a module, and ensure its interals don't leak out to client code.

Code is a living construct that is never “done”. You need to tend it like a garden, always improving and tidying it, or it withers and dies.

Have the same high standards for all the code you write, from little scripts to the inner loop of your critical system.

Write code that is exception safe and resource safe, always, even in contexts where you think it won’t matter. The code you wrote in a little ad-hoc script will inevitably find its way into more critical or long-running code.

Use the same language for the little tools and scripts in your system too. There are few good reasons to drop down into bash or Python scripts, and some considerable disadvantages.

In code, even the smallest details matter. This includes whitespace and layout!


### Design

Modelling - the act of creating models of the world - is a crucial skill, and one that’s been undervalued in recent years.

Model your domain using types.

Model your domain first, using data types and function signatures, pick implementation technologies and physical architecture later.

Implement functionality in vertical slices that span your whole system, and iterate to grow the system.

Resist the temptation to use your main domain types to describe interfaces or messages exchanged by your system. Use separate types for these, even if it entails some duplication, as these types will evolve differently over time.

Prefer immutability always. This applies to data storage as well as in-memory data structures.

When building programs that perform actions, model the actions as data, then write an interpreter that performs them. This makes your code much easier to test, monitor, debug, and refactor.

Dependency management is crucial, so do it from day one. The payoff for this mostly comes when your system is bigger, but it’s not expensive to do from the beginning and it saves massive problems later.

Avoid circular dependencies, always.


### Quality

I don’t care if you write the tests first, last, or in the middle, but all code must have good tests.

Tests should be performed at different levels of the system. Don’t get hung up on what these different levels of tests are called.

Absolutely all tests should be automated.

Test code should be written and maintained as carefully as production code.

Developers should write the tests.

Run tests on the production system too, to check it’s doing the right thing.


### Designing systems

A better system is often a smaller, simpler system.

To design healthy systems, divide and conquer. Split the problem into smaller parts.

Divide and conquer works recursively: divide the system into a hierarchy of simpler sub-systems and components.
	
_Corollary: When designing a system, there are more choices than a monolith vs. a thousand “microservices”._

The interface between parts is crucial. Aim for interfaces that are as small and simple as possible.

Data dependencies are insidious. Take particular care to manage the coupling introduced by such dependencies.

Plan to evolve data definitions over time, as they will inevitably change.

Asynchronous interfaces can be useful to remove temporal coupling between parts.

Every inter-process boundary incurs a great cost, losing type safety, and making it much harder to reason about failures. Only introduce such boundaries where absolutely necessary and where the benefits outweigh the cost.

Being able to tell what your system is doing is crucial, so make sure it’s observable.

Telling what your system has done in the past is even more crucial, so make sure it’s auditable.

A modern programming language is the most expressive tool we have for describing all aspects of a system.

This means: write configuration as code, unless it absolutely, definitely has to change at runtime.

Also, write the specification of the system as executable code.

And, use code to describe the infrastructure of your system, in the same language as the rest of the code. Write code that interprets the description of your system to provision actual physical infrastructure.

At the risk of repeating myself: everything is code.

_Corollary: if you’re writing JSON or YAML by hand, you’re doing it wrong. These are formats for the machines, not for humans to produce and consume. (Don’t despair though: most people do this, I do too, so you’re not alone! Let's just try to aim for something better)._

The physical manifestation of your system (e.g. choices of storage, messaging, RPC technology, packaging and scheduling etc) should usually be an implementation detail, not the main aspect of the system that the rest is built around.

It should be easy to change the underlying technologies (e.g. for data storage, messaging, execution environment) used by a component in your system, this should not affect large parts of your code base.

You should have at least two physical manifestations of your system: a fully integrated in-memory one for testing, and the real physical deployment. They should be functionally equivalent.

You should be able to run a local version of your system on a developer’s computer with a single command. With the capacity of modern computers, there is absolutely no rational reason why this isn’t feasible, even for big, complex systems.

There is a running theme here: separate the description of _what_ a system does from _how_ it does it. This is probably the single most important consideration when creating a system.


### Building systems

For a new system, get a walking skeleton deployed to production as soon as possible.

Your master branch should always be deployable to production.

Use feature branches if you like. Modern version control tools make merging easy enough that it’s not a problem to let these be long-lived in some cases.

Ideally, deploy automatically to production on every update to master. If that’s not feasible, it should be a one-click action to perform the deployment.

Maintain a separate environment for situations when you find it useful to test code separately from production. Avoid more than one such extra environment, as this introduces overheads and cost.

Prefer feature flags and similar mechanisms to control what's enabled in production over separate test/staging environments and manual promotion of releases.

Get in the habit of deploying from master to production from the very beginning of a project. Doing this shapes both your system and how you work with it for the better.

In fact, follow all these practices from the very beginning of a new system. Retrofitting them later is much, much harder.


### Technology

Beware of hyped or fashionable technologies. The fundamentals of computer science and engineering don’t change much over time.

Keep up with latest developments in technology to see how they can help you, but be realistic about what they can do.

Choose your data storage backend according to the shape of data, types of queries needed, patterns of writes vs. reads, performance requirements, and more. Every use case is different.

That said, PostgreSQL should be your default and you should only pick something else if you have a good reason.

## add dir

[Add dir="auto" to your inputs and textareas | Hacker News](https://news.ycombinator.com/item?id=37233902)
[PSA: Add dir="auto" to your inputs and textareas. | Mo - Pure...](https://mough.xyz/312/psa-add-dir-auto-to-your-inputs-and-textareas)
